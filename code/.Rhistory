first.choice<-sum(
matrix(inclusive.value$inclusive.val, nrow=nrow(inclusive.value), ncol=S),
matrix(rgev(S, xi = 0, mu = 0, beta = 1), nrow=nrow(inclusive.value), ncol=S)
)
dim(first.choice)
class(first.choice)
first.choice<-
matrix(inclusive.value$inclusive.val, nrow=nrow(inclusive.value), ncol=S) +
matrix(rgev(S, xi = 0, mu = 0, beta = 1), nrow=nrow(inclusive.value), ncol=S)
class(first.choice)
dim(first.choice)
inclusive.value
first.choice<-ldply(seq(S), function() inclusive.value$inclusive.val+rgev(length(inclusive.val), xi = 0, mu = 0, beta = 1))
first.choice<-ldply(seq(S), function(l) inclusive.value$inclusive.val+rgev(length(inclusive.val), xi = 0, mu = 0, beta = 1))
inclusive.value$inclusive.val
S<-10^2
first.choice<-ldply(seq(S), function(l) inclusive.value$inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1))
first.choice
vals<-expand.grid(bucket=1:10, choices=c('a', 'b', 'c', 'd', 'e')) %>%
mutate(val=rnorm(n()))
vals
lambda<-select(vals, bucket) %>%
unique() %>%
mutate(lambda=runif(n()))
inclusive.value<-left_join(vals, lambda, by='bucket') %>%
group_by(bucket) %>%
summarise(lambda=unique(lambda), inclusive.val=log(sum(exp(val/lambda)))) %>%
mutate(inclusive.val=lambda*inclusive.val)
S<-10^2
vals<-expand.grid(bucket=1:10, choices=c('a', 'b', 'c', 'd', 'e')) %>%
mutate(val=rnorm(n()))
lambda<-select(vals, bucket) %>%
unique() %>%
mutate(lambda=runif(n()))
inclusive.value<-left_join(vals, lambda, by='bucket') %>%
group_by(bucket) %>%
summarise(lambda=unique(lambda), inclusive.val=log(sum(exp(val/lambda)))) %>%
mutate(inclusive.val=lambda*inclusive.val)
vals<-expand.grid(bucket=1:10, choices=c('a', 'b', 'c', 'd', 'e')) %>%
mutate(val=rnorm(n()))
lambda<-select(vals, bucket) %>%
unique() %>%
mutate(lambda=runif(n()))
vals<-expand.grid(bucket=1:10, choices=c('a', 'b', 'c', 'd', 'e')) %>%
mutate(val=rnorm(n()))
vals
lambda<-select(vals, bucket) %>%
unique()
lambda<-dplyr:select(vals, bucket) %>%
unique()
source('~/Dropbox/teaching/OPNS910/assignments/OPNS910_Hendel2006/solution/code/header.R')
S<-10^2
vals<-expand.grid(bucket=1:10, choices=c('a', 'b', 'c', 'd', 'e')) %>%
mutate(val=rnorm(n()))
lambda<-select(vals, bucket) %>%
unique() %>%
mutate(lambda=runif(n()))
vals<-expand.grid(bucket=1:10, choices=c('a', 'b', 'c', 'd', 'e')) %>%
mutate(val=rnorm(n()))
lambda<-dplyr:select(vals, bucket)
library('dplyr')
lambda<-select(vals, bucket)
?select
?dplyr::select
vals<-expand.grid(bucket=1:10, choices=c('a', 'b', 'c', 'd', 'e')) %>%
mutate(val=rnorm(n()))
lambda<-dplyr::select(vals, bucket)
vals<-expand.grid(bucket=1:10, choices=c('a', 'b', 'c', 'd', 'e')) %>%
mutate(val=rnorm(n()))
lambda<-select(vals, bucket)
?select
source('header.R')
library('fExtremes')
S<-10^2
vals<-expand.grid(bucket=1:10, choices=c('a', 'b', 'c', 'd', 'e')) %>%
mutate(val=rnorm(n()))
lambda<-select(vals, bucket) %>%
unique() %>%
mutate(lambda=runif(n()))
inclusive.value<-left_join(vals, lambda, by='bucket') %>%
group_by(bucket) %>%
summarise(lambda=unique(lambda), inclusive.val=log(sum(exp(val/lambda)))) %>%
mutate(inclusive.val=lambda*inclusive.val)
vals<-expand.grid(bucket=1:10, choices=c('a', 'b', 'c', 'd', 'e')) %>%
mutate(val=rnorm(n()))
lambda<-dplyr::select(vals, bucket) %>%
unique() %>%
mutate(lambda=runif(n()))
inclusive.value<-left_join(vals, lambda, by='bucket') %>%
group_by(bucket) %>%
summarise(lambda=unique(lambda), inclusive.val=log(sum(exp(val/lambda)))) %>%
mutate(inclusive.val=lambda*inclusive.val)
inclusive.value
vals<-expand.grid(bucket=1:10, choices=c('a', 'b', 'c', 'd', 'e')) %>%
mutate(val=rnorm(n()))
lambda<-dplyr::select(vals, bucket) %>%
unique() %>%
mutate(lambda=runif(n()))
inclusive.value<-left_join(vals, lambda, by='bucket') %>%
group_by(bucket) %>%
summarise(lambda=unique(lambda), inclusive.val=log(sum(exp(val/lambda)))) %>%
mutate(inclusive.val=lambda*inclusive.val)
inclusive.value$inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1)
y=inclusive.value$inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1)
y
class(y)
filter(y, rank(val, ties.method="first")==1)
rank(y)
?rank
which(y, y=max(y))
which(y, y==max(y))
which(y==max(y))
vals=inclusive.value$inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1)
which(vals==max(vals))[1]
vals
vals<-expand.grid(bucket=1:10, choices=c('a', 'b', 'c', 'd', 'e')) %>%
mutate(val=rnorm(n()))
lambda<-dplyr::select(vals, bucket) %>%
unique() %>%
mutate(lambda=runif(n()))
inclusive.value<-left_join(vals, lambda, by='bucket') %>%
group_by(bucket) %>%
summarise(lambda=unique(lambda), inclusive.val=log(sum(exp(val/lambda)))) %>%
mutate(inclusive.val=lambda*inclusive.val)
first.choice<-ldply(seq(S), function(l){
vals=inclusive.value$inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1)
which(vals==max(vals))[1]
})
first.choice
inclusive.value
mutate(inclusive.value, val=inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1)) %>%
filter(rank(val, ties.method="first")==1)
mutate(inclusive.value, val=inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1))
y=mutate(inclusive.value, val=inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1))
filter(y, rank(val, ties.method="first")==1)
y
class(y)
mutate(y, rank=rank(val))
filter(y, rank('val', ties.method="first")==1)
y
filter(y, rank(val, ties.method="first")==1)
filter(y, rank(y$val, ties.method="first")==1)
filter(y, rank(y$val)==1)
filter(y, rank(val)==1)
y
y$r=y$val
filter(y, rank(r)==1)
mutate(inclusive.value, val=inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1)) %>%
select(bucket, val)
mutate(inclusive.value, val=inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1))
mutate(inclusive.value, val=inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1)) %>%
dplyr:select(bucket, val)
mutate(inclusive.value, val=inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1)) %>%
dplyr::select(bucket, val)
mutate(inclusive.value, val=inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1)) %>%
dplyr::select(bucket, val) %>%
filter(rank(val, ties.method="first")==1)
mutate(inclusive.value, val=inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1)) %>%
dplyr::select(bucket, val) %>%
filter(rank(val)==1)
mutate(inclusive.value, val=inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1)) %>%
dplyr::select(bucket, val) %>%
filter(abs(val)>1)
mutate(inclusive.value, val=inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1)) %>%
dplyr::select(bucket, val)
mutate(inclusive.value, value=inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1)) %>%
dplyr::select(bucket, value) %>%
filter(abs(value)>1)
source('header.R')
library('fExtremes')
S<-10^2
vals<-expand.grid(bucket=1:10, choices=c('a', 'b', 'c', 'd', 'e')) %>%
mutate(val=rnorm(n()))
lambda<-dplyr::select(vals, bucket) %>%
unique() %>%
mutate(lambda=runif(n()))
inclusive.value<-left_join(vals, lambda, by='bucket') %>%
group_by(bucket) %>%
summarise(lambda=unique(lambda), inclusive.val=log(sum(exp(val/lambda)))) %>%
mutate(inclusive.val=lambda*inclusive.val)
mutate(inclusive.value, value=inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1)) %>%
dplyr::select(bucket, value)
mutate(inclusive.value, value=inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1)) %>%
dplyr::select(bucket, value) %>%
filter(abs(value)>1)
mutate(inclusive.value, value=inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1)) %>%
dplyr::select(bucket, value) %>%
filter(value>1)
mutate(inclusive.value, value=inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1)) %>%
dplyr::select(bucket, value) %>%
filter(bucket>1)
mutate(inclusive.value, value=inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1)) %>%
dplyr::select(bucket, value)
y=mutate(inclusive.value, value=inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1)) %>%
dplyr::select(bucket, value)
y
class(y)
filter(y, bucket=3)
filter(y, bucket==3)
?filter
mutate(inclusive.value, value=inclusive.val+rgev(nrow(inclusive.value), xi = 0, mu = 0, beta = 1)) %>%
dplyr::select(bucket, value) %>%
dplyr::filter(bucket>1)
library('dplyr')
search()
library('dplyr', pos=1)
search()
?library
?search
detach('fExtremes')
source('header.R')
library('fExtremes', pos=20)
search()
source('header.R')
makeData()
source('~/Dropbox/teaching/OPNS523/labs/OPNS_NestedLogit_lab/github/code/modules/makeData.R')
makeData()
varSave
source('~/Dropbox/teaching/OPNS523/labs/OPNS_NestedLogit_lab/github/code/modules/makeData.R')
makeData()
val=read.rds('choice_values.rds')
source('header.R')
makeData()
val=readRDS('choice_values.rds')
val=readRDS(paste0(varSave, 'choice_values.rds'))
lambda=readRDS(paste0(varSave, 'lambda_values.rds'))
val
lambda
#Nested logit coding assignment
source('header.R')
#Load data
val<-readRDS(paste0(varSave, 'choice_values.rds'))
lambda<-readRDS(paste0(varSave, 'lambda_values.rds'))
#Nested logit coding assignment
source('header.R')
#Load data
val<-readRDS(paste0(varSave, 'choice_values.rds'))
lambda<-readRDS(paste0(varSave, 'lambda_values.rds'))
help(rgev)
size = 10000
eps<- rgev(size, xi = 0, mu = 0, beta = 1)
eta<- rgev(size, xi = 0, mu = 0, beta = 1)
View(lambda)
View(val)
library('plyr')
eps<- raply(3,rgev(size, xi = 0, mu = 0, beta = 1))
eta<- raply(3,rgev(size, xi = 0, mu = 0, beta = 1))
eps<- rdply(3,rgev(size, xi = 0, mu = 0, beta = 1))
eta<- rdply(3,rgev(size, xi = 0, mu = 0, beta = 1))
View(eta)
View(eps)
help(rdply)
library('dplyr')
#Nested logit coding assignment
source('header.R')
#Load data
val<-readRDS(paste0(varSave, 'choice_values.rds'))
lambda<-readRDS(paste0(varSave, 'lambda_values.rds'))
# Simulate 10,000 choices corresponding to V_ik and lambda_k values:
N <- 10^5
epsilon <- rgev(n = nrow(lambda)*N, xi = 0, mu = 0, beta = 1)
eta <- rgev(n = length(unique(val$choice))*N, xi = 0, mu = 0, beta = 1)
# 1 under the traditional specification where epsilon_k resolves before eta_i
IV <- left_join(val, lambda, by = "bucket") %>%
group_by(bucket) %>%
summarise(lambda = unique(lambda), iv = log(sum(exp(val/lambda)))) %>%
mutate(iv = lambda * iv)
nest_choice <- data.frame(
"bucket" = apply(IV$iv + matrix(epsilon,nrow = 3,byrow = TRUE),2,which.max)
)
# nest_choice <- ldply(seq(N), function(x){
#   util = IV$iv + rgev(n = nrow(IV), xi = 0, mu = 0, beta = 1)
#   which.max(util)
# })
item_choice1 <- data.frame(
"bucket" = nest_choice$bucket,
"choice" = LETTERS[
apply(
matrix(
left_join(nest_choice,val,by="bucket")$val,
nrow = length(unique(val$choice)),
ncol = N) +
matrix(eta,nrow = 3,byrow = TRUE),
2,which.max)
]
)
# 2 under the single-shot specification where epsilon_k and eta_i both resolve up front
a <- matrix(eta,nrow = 3,byrow = TRUE)
U2 <- apply(
temp<-
val$val +
matrix(rep(epsilon,3),nrow = 9, byrow = TRUE) +
rep(lambda$lambda,3) *
a[rep(seq(nrow(a)),each = 3),],
2,
which.max
)
item_choice2 <- data.frame(
"bucket" = val$bucket[U2],
"choice" = val$choice[U2]
)
# Estimate choice probabilities and calculate covariance matrix using bootstrap
# 1  under the traditional specification where epsilon_k resolves before eta_i
Prob1 <- data.frame(
ProbA1 = with(item_choice1,sum(bucket == 1 & choice == "A")/nrow(item_choice1)),
ProbB1 = with(item_choice1,sum(bucket == 1 & choice == "B")/nrow(item_choice1)),
ProbC1 = with(item_choice1,sum(bucket == 1 & choice == "C")/nrow(item_choice1)),
ProbA2 = with(item_choice1,sum(bucket == 2 & choice == "A")/nrow(item_choice1)),
ProbB2 = with(item_choice1,sum(bucket == 2 & choice == "B")/nrow(item_choice1)),
ProbC2 = with(item_choice1,sum(bucket == 2 & choice == "C")/nrow(item_choice1)),
ProbA3 = with(item_choice1,sum(bucket == 3 & choice == "A")/nrow(item_choice1)),
ProbB3 = with(item_choice1,sum(bucket == 3 & choice == "B")/nrow(item_choice1)),
ProbC3 = with(item_choice1,sum(bucket == 3 & choice == "C")/nrow(item_choice1))
)
types<- array(val[,1:2])
Prob11<- mdply(types, function(k,i) with(item_choice1,sum(bucket == toString(k) & choice == toString(i))/nrow(item_choice1)) )
# 2 under the single-shot specification where epsilon_k and eta_i both resolve up front
Prob2 <- data.frame(
ProbA1 = with(item_choice2,sum(bucket == 1 & choice == "A")/nrow(item_choice2)),
ProbB1 = with(item_choice2,sum(bucket == 1 & choice == "B")/nrow(item_choice2)),
ProbC1 = with(item_choice2,sum(bucket == 1 & choice == "C")/nrow(item_choice2)),
ProbA2 = with(item_choice2,sum(bucket == 2 & choice == "A")/nrow(item_choice2)),
ProbB2 = with(item_choice2,sum(bucket == 2 & choice == "B")/nrow(item_choice2)),
ProbC2 = with(item_choice2,sum(bucket == 2 & choice == "C")/nrow(item_choice2)),
ProbA3 = with(item_choice2,sum(bucket == 3 & choice == "A")/nrow(item_choice2)),
ProbB3 = with(item_choice2,sum(bucket == 3 & choice == "B")/nrow(item_choice2)),
ProbC3 = with(item_choice2,sum(bucket == 3 & choice == "C")/nrow(item_choice2))
)
types
Prob11<- mdply(types, function(k,i) with(item_choice1,sum(bucket == k & choice == i)/nrow(item_choice1)) )
?dcast
Prob1<-
mdply(k_i,
function(k,i) with(item_choice1,sum(bucket == k & choice == i)/nrow(item_choice1))
) %>%
dcast(bucket + choice ~ V1,mean)
k_i<- array(val[,1:2])
Prob1<-
mdply(k_i,
function(k,i) with(item_choice1,sum(bucket == k & choice == i)/nrow(item_choice1))
) %>%
dcast(bucket + choice ~ V1,mean)
Prob1<-
mdply(k_i,
function(k,i) with(item_choice1,sum(bucket == k & choice == i)/nrow(item_choice1))
) %>%
dcast(X1 + X2 ~ V1,mean)
Prob1 <- data.frame(
ProbA1 = with(item_choice1,sum(bucket == 1 & choice == "A")/nrow(item_choice1)),
ProbB1 = with(item_choice1,sum(bucket == 1 & choice == "B")/nrow(item_choice1)),
ProbC1 = with(item_choice1,sum(bucket == 1 & choice == "C")/nrow(item_choice1)),
ProbA2 = with(item_choice1,sum(bucket == 2 & choice == "A")/nrow(item_choice1)),
ProbB2 = with(item_choice1,sum(bucket == 2 & choice == "B")/nrow(item_choice1)),
ProbC2 = with(item_choice1,sum(bucket == 2 & choice == "C")/nrow(item_choice1)),
ProbA3 = with(item_choice1,sum(bucket == 3 & choice == "A")/nrow(item_choice1)),
ProbB3 = with(item_choice1,sum(bucket == 3 & choice == "B")/nrow(item_choice1)),
ProbC3 = with(item_choice1,sum(bucket == 3 & choice == "C")/nrow(item_choice1))
)
k_i<- array(val[,1:2])
Prob11<-
mdply(k_i,
function(k,i) with(item_choice1,sum(bucket == k & choice == i)/nrow(item_choice1))
) %>%
dcast(X1 + X2 ~ V1,mean)
View(Prob11)
names(airquality) <- tolower(names(airquality))
aqm <- melt(airquality, id=c("month", "day"), na.rm=TRUE)
acast(aqm, day ~ month ~ variable)
acast(aqm, month ~ variable, mean)
acast(aqm, month ~ variable, mean, margins = TRUE)
dcast(aqm, month ~ variable, mean, margins = c("month", "variable"))
Prob11<-
mdply(k_i,
function(k,i) with(item_choice1,sum(bucket == k & choice == i)/nrow(item_choice1))
)
View(Prob11)
k_i<- array(val[,1:2])
Prob1=<-
mdply(k_i,
function(k,i) with(item_choice1,sum(bucket == k & choice == i)/nrow(item_choice1))
) %>%
colnames("bucket", "choice", "prob")
Prob1=<-
mdply(k_i,
function(k,i) with(item_choice1,sum(bucket == k & choice == i)/nrow(item_choice1))
)%>%
data.frame %>%
colnames("bucket", "choice", "prob")
Prob1=<-
mdply(k_i,
function(k,i) with(item_choice1,sum(bucket == k & choice == i)/nrow(item_choice1))
)
colnames(Prob1)<- c("bucket", "choice", "prob")
Prob2=<-
mdply(k_i,
function(k,i) with(item_choice2,sum(bucket == k & choice == i)/nrow(item_choice2))
)
colnames(Prob2)<- c("bucket", "choice", "prob")
View(Prob1)
View(Prob2)
Prob1 <- data.frame(
ProbA1 = with(item_choice1,sum(bucket == 1 & choice == "A")/nrow(item_choice1)),
ProbB1 = with(item_choice1,sum(bucket == 1 & choice == "B")/nrow(item_choice1)),
ProbC1 = with(item_choice1,sum(bucket == 1 & choice == "C")/nrow(item_choice1)),
ProbA2 = with(item_choice1,sum(bucket == 2 & choice == "A")/nrow(item_choice1)),
ProbB2 = with(item_choice1,sum(bucket == 2 & choice == "B")/nrow(item_choice1)),
ProbC2 = with(item_choice1,sum(bucket == 2 & choice == "C")/nrow(item_choice1)),
ProbA3 = with(item_choice1,sum(bucket == 3 & choice == "A")/nrow(item_choice1)),
ProbB3 = with(item_choice1,sum(bucket == 3 & choice == "B")/nrow(item_choice1)),
ProbC3 = with(item_choice1,sum(bucket == 3 & choice == "C")/nrow(item_choice1))
)
k_i<- array(val[,1:2])
Prob11=<-
mdply(k_i,
function(k,i) with(item_choice1,sum(bucket == k & choice == i)/nrow(item_choice1))
)
Prob22=<-
mdply(k_i,
function(k,i) with(item_choice2,sum(bucket == k & choice == i)/nrow(item_choice2))
)
# 2 under the single-shot specification where epsilon_k and eta_i both resolve up front
Prob2 <- data.frame(
ProbA1 = with(item_choice2,sum(bucket == 1 & choice == "A")/nrow(item_choice2)),
ProbB1 = with(item_choice2,sum(bucket == 1 & choice == "B")/nrow(item_choice2)),
ProbC1 = with(item_choice2,sum(bucket == 1 & choice == "C")/nrow(item_choice2)),
ProbA2 = with(item_choice2,sum(bucket == 2 & choice == "A")/nrow(item_choice2)),
ProbB2 = with(item_choice2,sum(bucket == 2 & choice == "B")/nrow(item_choice2)),
ProbC2 = with(item_choice2,sum(bucket == 2 & choice == "C")/nrow(item_choice2)),
ProbA3 = with(item_choice2,sum(bucket == 3 & choice == "A")/nrow(item_choice2)),
ProbB3 = with(item_choice2,sum(bucket == 3 & choice == "B")/nrow(item_choice2)),
ProbC3 = with(item_choice2,sum(bucket == 3 & choice == "C")/nrow(item_choice2))
)
Prob11<-
mdply(k_i,
function(k,i) with(item_choice1,sum(bucket == k & choice == i)/nrow(item_choice1))
)
Prob22<-
mdply(k_i,
function(k,i) with(item_choice2,sum(bucket == k & choice == i)/nrow(item_choice2))
)
View(Prob1)
View(Prob11)
View(Prob2)
View(Prob22)
Prob11<-
mdply(k_i,
function(k,i) with(item_choice1,sum(bucket == k & choice == i)/nrow(item_choice1))
)
colnames(Prob11)<- c("bucket", "choice", "prob")
View(Prob11)
#Nested logit coding assignment
source('header.R')
#Load data
val<-readRDS(paste0(varSave, 'choice_values.rds'))
lambda<-readRDS(paste0(varSave, 'lambda_values.rds'))
# Simulate 10,000 choices corresponding to V_ik and lambda_k values:
N <- 10^5
epsilon <- rgev(n = nrow(lambda)*N, xi = 0, mu = 0, beta = 1)
eta <- rgev(n = length(unique(val$choice))*N, xi = 0, mu = 0, beta = 1)
# 1 under the traditional specification where epsilon_k resolves before eta_i
IV <- left_join(val, lambda, by = "bucket") %>%
group_by(bucket) %>%
summarise(lambda = unique(lambda), iv = log(sum(exp(val/lambda)))) %>%
mutate(iv = lambda * iv)
nest_choice <- data.frame(
"bucket" = apply(IV$iv + matrix(epsilon,nrow = 3,byrow = TRUE),2,which.max)
)
# nest_choice <- ldply(seq(N), function(x){
#   util = IV$iv + rgev(n = nrow(IV), xi = 0, mu = 0, beta = 1)
#   which.max(util)
# })
item_choice1 <- data.frame(
"bucket" = nest_choice$bucket,
"choice" = LETTERS[
apply(
matrix(
left_join(nest_choice,val,by="bucket")$val,
nrow = length(unique(val$choice)),
ncol = N) +
matrix(eta,nrow = 3,byrow = TRUE),
2,which.max)
]
)
# 2 under the single-shot specification where epsilon_k and eta_i both resolve up front
a <- matrix(eta,nrow = 3,byrow = TRUE)
U2 <- apply(
temp<-
val$val +
matrix(rep(epsilon,3),nrow = 9, byrow = TRUE) +
rep(lambda$lambda,3) *
a[rep(seq(nrow(a)),each = 3),],
2,
which.max
)
item_choice2 <- data.frame(
"bucket" = val$bucket[U2],
"choice" = val$choice[U2]
)
# Estimate choice probabilities and calculate covariance matrix using bootstrap
# 1 under the traditional specification where epsilon_k resolves before eta_i
# 2 under the single-shot specification where epsilon_k and eta_i both resolve up front
k_i<- array(val[,1:2])
Prob1<-
mdply(k_i,
function(k,i) with(item_choice1,sum(bucket == k & choice == i)/nrow(item_choice1))
)
colnames(Prob1)<- c("bucket", "choice", "prob")
Prob2<-
mdply(k_i,
function(k,i) with(item_choice2,sum(bucket == k & choice == i)/nrow(item_choice2))
)
colnames(Prob1)<- c("bucket", "choice", "prob")
